const _ = require('lodash');
const moment = require('moment');
const Promise = require('bluebird');
const debug = require('debug')('lib:rss');
const nconf = require('nconf');
const RSS = require('rss');
const fs = Promise.promisifyAll(require('fs'));
const path = require('path');
 
const mongo = require('./mongo');
const utils = require('./utils');

const fbtrexRSSplaceholder = "Welcome, you should wait 10 minutes circa to get this newsfeed populated, now the subscription is taken in account. fbTREX would stop to populate this feed if no request is seen in 5 days. updates would be automatic. You can find more specifics about the RSS settings in [here todo doc]";
const fbtrexRSSdescription = "This newsfeed is generated by the distributed observation of Facebook posts, collected with https://facebook.tracking.exposed browser extension; The posts are processed with a technical proceduce called semantic analysis, it extract the core meanings of the post linkable to existing wikipedia pages";
const fbtrexRSSproblem = "We can't provide a newsfeed on the information you requested. This is, normally, due because you look for a keyword which has not been seen recently. We permit to generate RSS only about voices which are part of wikipedia because this ensure we do not enable any kind of stalking. (editing wikipedia would not work). You can really use only label which are meaningful encyclopedic voices.";
const QUEUED_STRING = "queued";

/*
 * logic:
 * compute a feedId using the hash function
 * check if the query exists in mongodb://facebook/feeds
 *    if yes, check if exist an .xml file ready 
 *       if yes, return all the information
 *    if not, 
 *       add at the feed the query combo 
 *       raise exception error.message = 'queued'
 * this logic is not describing the validation made with 'labels' 
 */

function validateFeed(labels, feedId) {
    return Promise.map(labels, function(l) {
        return mongo
            .count(nconf.get('schema').semantics, { label: l })
            .then(function(amount) {
                if(!amount)
                    throw new Error("invalid label request");
            })
    })
    .then(function() {
        return mongo
            .read(nconf.get('schema').feeds, { id: feedId, created: true })
            .then(_.first)
            .then(function(feed) {
                /* label are valid combo, but do not exist */
                if(!feed || !feed.path) {
                    debug("Registering feed %s for %j", feedId, labels);
                    return mongo
                        .writeOne(nconf.get('schema').feeds, {
                            id: feedId,
                            insertAt: new Date(),
                            labels: labels,
                            created: false
                        })
                        .catch(function(error) {
                            if(error.code === 11000) {
                                debug("The feed %s already existing but not yet render", error.message);
                                throw new Error(QUEUED_STRING);
                            }
                            debug("Unexpected error [%s] forwarding up", error);
                            throw error;
                        })
                        .then(function() {
                            debug("The feed is queued now");
                            throw new Error(QUEUED_STRING);
                        });
                } else {
                    debug("Feed %j found: %j", labels, feed);
                    return feed;
                }
            });
    });
};

function feeds(req) {

    if(!_.endsWith(req.params.query, '.xml'))
        return { text: 'expected [*.xml]' };

    const labels = req.params.query.replace(/\.xml$/, '').split('+');
    debug("serving RSS feed %s", labels);
    const feedId = utils.hash(labels);

    return validateFeed(labels, feedId)
        .then(function(feed) {
            debug("xxx");
            return {text: 'fai' };
        })
        .catch(function(error) {
            /* this error message is fired by validateFeed, it happen
             * when a XML file do not exists yet, but would be in 10 minutes */
            if(error.message === QUEUED_STRING) {
                debug("Returning default message for %s", labels);
                return { 'text': produceDefault(labels, feedId) };
            }
            else {
                debug("Returning error message: %s", error.message);
                debug(produceError());
                return { text: produceError() };
            }
        });

    /* uno dei db deve avere una lista di semantiche per fare 
     * check con $in, per ora usiamo solo una mono-keyword */

    if(_.size(labels) > 1) 
        return { text: '+ not supported' };

    return mongo
        .readLimit(nconf.get('schema').labels, { label: _.first(labels) }, { when: -1 }, 20, 0)
        .tap(function(labels) {
            
        })
        .map(function(label) {
            return mongo
                .read(nconf.get('schema').metadata, { semanticId: label.semanticId, semantic: { $exists: true } })
                .then(function(metadata) {
                    return { metadata: _.first(metadata), label: label };
                });
        }, { concurrency: 1 })
        .then(function(entries) {

            if(_.size(entries) === 0) {
                debug("missing even one entry!");
            }

            _.each(entries, function(o) {

                let info = buildTitle(o.metadata);
                feed.item({
                    title: info.title,
                    description: JSON.stringify(o.metadata.texts),
                    url: info.permaLink ? info.permaLink : 'https://facebook.tracking.exposed/issues',
                    guid: info.guid,
                    date: info.publicationTime,
                });
            });

            return { text: feed.xml() };
        })
        .catch(function(error) {
            return { text: 'error ? ' + error };
        });
};

function buildTitle(metadata) {

    /* [photo|post|video] from "$name", with %d concepts */
    let attr = _.first(_.get(metadata, 'attributions'));
    let details = _.get(metadata, 'linkedtime');

    /* TODO COMPLETE */
    debug("%j", attr);
    debug("%j", details);

    return {
        title: 'fica',
        permaLink: 'fica',
        guid: 'fica',
        publicationTime: 'fica',
    };

};

function produceDefault(labels, feedId) {

    let feed = new RSS({
        title: `fbTREX ⏩ ${_.first(labels)}`,
        description: fbtrexRSSdescription,
        feed_url: 'https://facebook.tracking.exposed/feeds',
        ttl: 60
    });
    feed.item({
        title: `fbTREX Ⓧ  Invalid label!?`,
        description : fbtrexRSSplaceholder + "\n" + fbtrexRSSdescription,
        guid: feedId,
        date: moment().toISOString()
    });
    return feed.xml();
};


function produceError() {

    let feed = new RSS({
        title: `fbTREX Ⓧ  Error!?`,
        description: 'There is an error in your requested feed',
        feed_url: 'https://facebook.tracking.exposed/feeds/problems',
        ttl: 20
    });
    feed.item({
        title: `fbTREX Ⓧ  Invalid label!?`,
        description : fbtrexRSSproblem,
        guid: _.random(0, 0xffff),
        date: moment().toISOString()
    });
    return feed.xml();
};

module.exports = {
    feeds: feeds
};
