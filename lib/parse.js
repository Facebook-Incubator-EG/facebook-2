var _ = require('lodash');
var Promise = require('bluebird');
var fs = Promise.promisifyAll(require('fs'));
var debug = require('debug')('lib:parse');
var moment = require('moment');
var nconf = require('nconf'); 

const xpath = require('xpath');
const xmldom = require('xmldom');
const JSDOM = require('jsdom').JSDOM;

var mongo = require('./mongo');
var sequence = require('../parsers/components/utils/sequence');

nconf.argv().env().file({ file: "config/collector.json" });

function initialize(impression, repeat) {
    
    if(_.isUndefined(impression.id))
        throw new Error("impression missing");

    return mongo
        .readOne(nconf.get('schema').metadata, { id: impression.id })
        .then(function(i) {

            if( _.get(i, 'id') === impression.id && !repeat) {
                debug("metadata [%s] already exists: skipping", i.id);
                return null;
            }

            if( _.get(i, 'id') === impression.id && repeat)
                debug("metadata [%s] exists, but repeat is requested", i.id);

            const xmlerr = { warning: 0, error: 0, fatal: 0 };
            var domOptions = {
                  errorHandler:{
                      warning: function() { xmlerr.warning += 1; },
                      error: function() { xmlerr.error += 1; },
                      fatalError: function() { xmlerr.fatal += 1;  },
                  }
            };

            /* this is the envelope with get appended the metadata from the various parsers */
            return {
                impression,
                xmlerr,
                xpath,
                jsdom: new JSDOM(impression.html).window.document,
                dom: new xmldom.DOMParser(domOptions).parseFromString(impression.html),
            };
        });
}

function save(metadata) {
    /* this append and updated a metadata entry on the dedicated collection, the metadata.id === htmls.it */
    debug("Saving %d metadata objects", _.size(metadata));
    if(_.size(metadata))
        return mongo
            .writeMany(nconf.get('schema').metadata, metadata);
} 

function stats(metadata) {
    if(!_.size(metadata))
        return [];

    debug("saving stats for %d entries", _.size(metadata));

    const stats = _.map(metadata, function(e) {
        /* stats are generated by components/utils/stats.js,
         * all the stats are saved, even if duplicated */
        var r = e.stats;
        r.when = new Date();
        r.id = e.id;
        return r;
    });

    const cleanedMetadata = _.map(metadata, function(e) {
        return _.omit(e, ['stats', 'errors']);
    });

    return mongo
        .writeMany(nconf.get('schema').parserstats, stats)
        .return(cleanedMetadata);
}

function mark(metadata) {
    /* this is the second function called, when the html is marked as processed,
     * probably the condition `false` should be considered worthy */

    if(_.size(metadata))
        debug("mark the htmls (%d) as processed", _.size(metadata));
    return Promise.map(metadata, function(e) {
        return mongo
            .readOne(nconf.get('schema').htmls, { id: e.id })
            .then(function(existing) {
                existing.processed = true;
                return mongo
                    .updateOne(nconf.get('schema').htmls, { _id: existing._id }, existing);
            });
    }, { concurrency: 5});
}

function processImpression(input) {
    /* this is the function processing the parsers
     * it is call of every .id which should be analyzed */

    return new Promise(function() {
        return sequence(input);
    })
    .catch(function(error) {
        debug("[E] Unmanaged error in parser sequence: %s", error.message);
        return null;
    })
    .then(function(results) {
        const removef = ['dom', 'jsdom', 'xpath', 'xmlerr', 'impression'];
        const impressionFields = ['id', 'timelineId', 'userId', 'impressionOrder', 'impressionTime'];

        let r = _.omit(results, removef);
        _.extend(r, _.pick(results.impression, impressionFields));

        /* log some stats about the success ratio, or compute the 
         * summary which would be saved later by 'save' */
        return r;
    })
    .tap(function(metadata) {
        debug("→ http://localhost:8000/revision/%s", metadata.id);
        debug("→ %s", JSON.stringify(metadata, undefined, 2));
    })
    .catch(function(error) {
        debug("[E] %s", error.message);
        return null;
    });
};

function bytimeline(targetTmlnId) {

    debug("addressing timeline %s", targetTmlnId);
    const repeat = nconf.get('repeat') || false;
    const htmlfilter = repeat ? 
        { timelineId: targetTmlnId } :
        { timelineId: targetTmlnId, processed: { $exists: false } };

    return mongo
        .read(nconf.get('schema').htmls, htmlfilter)
        .map(function(html) {
            return mongo
                .readOne(nconf.get('schema').impressions, { id: html.impressionId })
                .then(function(impression) {
                    _.unset(impression, 'id');
                    _.unset(impression, 'htmlId');
                    return _.merge(html, impression);
                });
        }, { concurrency: 10 })
        .then(_.compact)
        .then(function(impressions) {
            return _.orderBy(impressions, { impressionOrder: -1 });
        })
        .tap(function(impressions) {
            debug("Found %d impressions associated: %d [%s] - %d [%s] (%s)",
                _.size(impressions),
                _.first(impressions).impressionOrder,
                moment(_.first(impressions).impressionTime).format("DD/MMM HH:mm"),
                _.last(impressions).impressionOrder,
                moment(_.last(impressions).impressionTime).format("DD/MMM HH:mm"),
                moment.duration( moment(_.last(impressions).impressionTime) - moment(_.first(impressions).impressionTime )).humanize()
            );
        })
        .map(function(e) {
            return initialize(e, repeat)
                .then(function(impression) {
                    if(!_.isNull(impression))
                        return processImpression(impression);
                });
        }, { concurrency: 10})
        .then(_.compact)
        .then(stats)
        .tap(mark)
        .tap(save);
}

module.exports = {
    processImpression: processImpression,
    initialize: initialize,
    save: save,
    mark: mark,
    stats: stats,
    bytimeline: bytimeline,
};
