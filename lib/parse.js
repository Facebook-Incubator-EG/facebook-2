const _ = require('lodash');
const Promise = require('bluebird');
const debug = require('debug')('lib:parse');
const moment = require('moment');
const nconf = require('nconf'); 
const xpath = require('xpath');
const xmldom = require('xmldom');
const JSDOM = require('jsdom').JSDOM;

const mongo = require('./mongo');
const sequence = require('../parsers/components/utils/sequence');

nconf.argv().env().file({ file: "config/collector.json" });

function initialize(impression, repeat) {
    
    if(_.isUndefined(impression.id))
        throw new Error("impression missing");

    return mongo
        .readOne(nconf.get('schema').metadata, { id: impression.id })
        .then(function(i) {

            if( _.get(i, 'id') === impression.id && !repeat) {
                debug("metadata [%s] already exists: skipping", i.id);
                return null;
            }

            if( _.get(i, 'id') === impression.id && repeat)
                debug("metadata [%s] exists, but repeat is requested", i.id);

            const xmlerr = { warning: 0, error: 0, fatal: 0 };
            var domOptions = {
                  errorHandler:{
                      warning: function() { xmlerr.warning += 1; },
                      error: function() { xmlerr.error += 1; },
                      fatalError: function() { xmlerr.fatal += 1;  },
                  }
            };

            /* this is the envelope with get appended the metadata from the various parsers */
            return {
                impression,
                xmlerr,
                xpath,
                jsdom: new JSDOM(impression.html).window.document,
                dom: new xmldom.DOMParser(domOptions).parseFromString(impression.html),
            };
        });
}

function save(metadata) {
    if(!_.size(metadata))
        return [];

    /* this update three columns (with different data retention politcy) 
     * the metadata.id === htmls.id */
    const stats = _.map(metadata, function(e) {
        /* stats are generated by components/utils/stats.js,
         * all the stats are saved, even if duplicated */
        var r = e.stats;
        r.when = new Date();
        r.id = e.id;
        return r;
    });
    const onlyMetadata = _.map(metadata, function(e) {
        return _.omit(e, ['stats', 'errors', 'summary']);
    });
    const errors = _.reduce(metadata, function(memo, e) {
        if(!_.size(e.errors))
            return memo;
        var r = {
            errors: e.errors,
            when:  new Date(),
            id: e.id,
            timelineId: e.timelineId
        }
        memo.push(r);
        return memo;
    }, []);

    const summary = _.map(metadata, function(e) {
        /* this do not take the ID because is an information we can eventually share
         * to the outside */
        return e.summary;
    });

    let chain = [
        mongo.writeMany(nconf.get('schema').parserstats, stats),
        mongo.writeMany(nconf.get('schema').metadata, onlyMetadata),
        mongo.writeMany(nconf.get('schema').summary, summary)
    ];
    if(_.size(errors)) {
        chain.push(
            mongo.writeMany(nconf.get('schema').errors, errors)
        );
    }
    debug("Received %d (stats, metadata) and %d errors",
        _.size(metadata), _.size(errors)
    );
    return Promise
        .all(chain)
        .return({
            metadata: _.size(metadata),
            errors: _.size(errors)
        });
}

function mark(metadata) {
    /* this is the second function called, when the html is marked as processed,
     * probably the condition `false` should be considered worthy */

    return Promise.map(metadata, function(e) {
        return mongo
            .readOne(nconf.get('schema').htmls, { id: e.id })
            .then(function(existing) {
                existing.processed = true;
                return mongo
                    .updateOne(nconf.get('schema').htmls, { _id: existing._id }, existing);
            });
    }, { concurrency: 5});
}

function parseHTML(htmlfilter, repeat) {
    return mongo
        .read(nconf.get('schema').htmls, htmlfilter)
        .map(function(html) {
            return mongo
                .readOne(nconf.get('schema').impressions, { id: html.impressionId })
                .then(function(impression) {
                    _.unset(impression, 'id');
                    _.unset(impression, 'htmlId');
                    return _.merge(html, impression);
                });
        }, { concurrency: 10 })
        .then(_.compact)
        .then(function(impressions) {
            return _.orderBy(impressions, { impressionOrder: -1 });
        })
        .tap(function(impressions) {
            if(_.size(impressions)) {
                const firstT = moment(_.first(impressions).impressionTime).format("DD/MMM HH:mm");
                const lastT = moment(_.last(impressions).impressionTime).format("DD/MMM HH:mm");
                debug("Found %d impressions associated: %d [%s] - %d [%s] (%s)",
                    _.size(impressions),
                    _.first(impressions).impressionOrder, firstT,
                    _.last(impressions).impressionOrder, lastT,
                    moment.duration(
                        moment(_.last(impressions).impressionTime) -
                        moment(_.first(impressions).impressionTime ))
                    .humanize()
                );
            }
        })
        .map(function(e) {
            return initialize(e, repeat);
        }, { concurrency: 10})
        .then(_.compact)
        .map(sequence)
        /* this is the function processing the parsers
         * it is call of every .id which should be analyzed */
        .catch(function(error) {
            debug("[E] Unmanaged error in parser sequence: %s", error.message);
            console.log(error.stack);
            return null;
        })
        .map(function(results) {
            const removef = ['dom', 'jsdom', 'xpath', 'xmlerr', 'impression'];
            const impressionFields = ['id', 'timelineId', 'userId', 'impressionOrder', 'impressionTime'];

            let r = _.omit(results, removef);
            _.extend(r, _.pick(results.impression, impressionFields));

            /* log some stats about the success ratio, or compute the 
             * summary which would be saved later by 'save' */
            return r;
        })
        .tap(function(metadata) {
            debug("⁂  completed and filtered %d metadata", _.size(metadata));
            if(!_.isUndefined(nconf.get('verbose')))
                debug("⁂  %s", JSON.stringify(metadata, undefined, 2));
        })
        .tap(mark)
        .then(save)
        .catch(function(error) {
            debug("[error after parsing] %s", error.message);
            console.log(error.stack);
            return null;
        });
}

module.exports = {
    initialize: initialize,
    save: save,
    mark: mark,
    parseHTML: parseHTML,
};
